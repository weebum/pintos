!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
BLOCK_CNT	block.h	/^    BLOCK_CNT                    \/* Number of Pintos block types. *\/$/;"	e	enum:block_type
BLOCK_FILESYS	block.h	/^    BLOCK_FILESYS,               \/* File system. *\/$/;"	e	enum:block_type
BLOCK_FOREIGN	block.h	/^    BLOCK_FOREIGN,               \/* Owned by non-Pintos operating system. *\/$/;"	e	enum:block_type
BLOCK_KERNEL	block.h	/^    BLOCK_KERNEL,                \/* Pintos OS kernel. *\/$/;"	e	enum:block_type
BLOCK_RAW	block.h	/^    BLOCK_RAW = BLOCK_ROLE_CNT,  \/* "Raw" device with unidentified contents. *\/$/;"	e	enum:block_type
BLOCK_ROLE_CNT	block.h	/^    BLOCK_ROLE_CNT,$/;"	e	enum:block_type
BLOCK_SCRATCH	block.h	/^    BLOCK_SCRATCH,               \/* Scratch. *\/$/;"	e	enum:block_type
BLOCK_SECTOR_SIZE	block.h	11;"	d
BLOCK_SWAP	block.h	/^    BLOCK_SWAP,                  \/* Swap. *\/$/;"	e	enum:block_type
CHANNEL_CNT	ide.c	79;"	d	file:
CMD_IDENTIFY_DEVICE	ide.c	49;"	d	file:
CMD_READ_SECTOR_RETRY	ide.c	50;"	d	file:
CMD_WRITE_SECTOR_RETRY	ide.c	51;"	d	file:
CMOS_REG_IO	rtc.c	11;"	d	file:
CMOS_REG_SET	rtc.c	10;"	d	file:
COL_CNT	vga.c	14;"	d	file:
CONTROL_REG	shutdown.c	18;"	d	file:
CTL_SRST	ide.c	39;"	d	file:
DATA_REG	kbd.c	12;"	d	file:
DEVICES_BLOCK_H	block.h	2;"	d
DEVICES_IDE_H	ide.h	2;"	d
DEVICES_INPUT_H	input.h	2;"	d
DEVICES_INTQ_H	intq.h	2;"	d
DEVICES_KBD_H	kbd.h	2;"	d
DEVICES_PARTITION_H	partition.h	2;"	d
DEVICES_PIT_H	pit.h	2;"	d
DEVICES_SERIAL_H	serial.h	2;"	d
DEVICES_SHUTDOWN_H	shutdown.h	2;"	d
DEVICES_SPEAKER_H	speaker.h	2;"	d
DEVICES_TIMER_H	timer.h	2;"	d
DEVICES_VGA_H	vga.h	2;"	d
DEV_DEV	ide.c	44;"	d	file:
DEV_LBA	ide.c	43;"	d	file:
DEV_MBS	ide.c	42;"	d	file:
FCR_REG	serial.c	31;"	d	file:
GRAY_ON_BLACK	vga.c	22;"	d	file:
IER_RECV	serial.c	37;"	d	file:
IER_REG	serial.c	23;"	d	file:
IER_XMIT	serial.c	38;"	d	file:
IIR_REG	serial.c	30;"	d	file:
INTQ_BUFSIZE	intq.h	21;"	d
IO_BASE	serial.c	18;"	d	file:
LCR_DLAB	serial.c	42;"	d	file:
LCR_N81	serial.c	41;"	d	file:
LCR_REG	serial.c	32;"	d	file:
LSR_DR	serial.c	48;"	d	file:
LSR_REG	serial.c	34;"	d	file:
LSR_THRE	serial.c	49;"	d	file:
LS_REG	serial.c	26;"	d	file:
MCR_OUT2	serial.c	45;"	d	file:
MCR_REG	serial.c	33;"	d	file:
MS_REG	serial.c	27;"	d	file:
PIT_HZ	pit.c	15;"	d	file:
PIT_PORT_CONTROL	pit.c	11;"	d	file:
PIT_PORT_COUNTER	pit.c	12;"	d	file:
POLL	serial.c	/^static enum { UNINIT, POLL, QUEUE } mode;$/;"	e	enum:__anon1	file:
PRDSNu	block.h	19;"	d
QUEUE	serial.c	/^static enum { UNINIT, POLL, QUEUE } mode;$/;"	e	enum:__anon1	file:
RBR_REG	serial.c	21;"	d	file:
ROW_CNT	vga.c	15;"	d	file:
RTCSA_UIP	rtc.c	30;"	d	file:
RTCSB_24HR	rtc.c	35;"	d	file:
RTCSB_DM	rtc.c	34;"	d	file:
RTCSB_SET	rtc.c	33;"	d	file:
RTC_H	rtc.h	2;"	d
RTC_REG_A	rtc.c	24;"	d	file:
RTC_REG_B	rtc.c	25;"	d	file:
RTC_REG_C	rtc.c	26;"	d	file:
RTC_REG_D	rtc.c	27;"	d	file:
RTC_REG_HOUR	rtc.c	18;"	d	file:
RTC_REG_MDAY	rtc.c	19;"	d	file:
RTC_REG_MIN	rtc.c	17;"	d	file:
RTC_REG_MON	rtc.c	20;"	d	file:
RTC_REG_SEC	rtc.c	16;"	d	file:
RTC_REG_YEAR	rtc.c	21;"	d	file:
SHUTDOWN_NONE	shutdown.h	/^    SHUTDOWN_NONE,              \/* Loop forever. *\/$/;"	e	enum:shutdown_type
SHUTDOWN_POWER_OFF	shutdown.h	/^    SHUTDOWN_POWER_OFF,         \/* Power off the machine (if possible). *\/$/;"	e	enum:shutdown_type
SHUTDOWN_REBOOT	shutdown.h	/^    SHUTDOWN_REBOOT,            \/* Reboot the machine (if possible). *\/$/;"	e	enum:shutdown_type
SPEAKER_GATE_ENABLE	speaker.c	11;"	d	file:
SPEAKER_PORT_GATE	speaker.c	8;"	d	file:
STA_BSY	ide.c	34;"	d	file:
STA_DRDY	ide.c	35;"	d	file:
STA_DRQ	ide.c	36;"	d	file:
THR_REG	serial.c	22;"	d	file:
TIMER_FREQ	timer.h	8;"	d
UNINIT	serial.c	/^static enum { UNINIT, POLL, QUEUE } mode;$/;"	e	enum:__anon1	file:
all_blocks	block.c	/^static struct list all_blocks = LIST_INITIALIZER (all_blocks);$/;"	v	typeref:struct:list	file:
ata_disk	ide.c	/^struct ata_disk$/;"	s	file:
aux	block.c	/^    void *aux;                          \/* Extra data owned by driver. *\/$/;"	m	struct:block	file:
bcd_to_bin	rtc.c	/^bcd_to_bin (uint8_t x)$/;"	f	file:
block	block.c	/^struct block$/;"	s	file:
block	partition.c	/^    struct block *block;                \/* Underlying block device. *\/$/;"	m	struct:partition	typeref:struct:partition::block	file:
block_by_role	block.c	/^static struct block *block_by_role[BLOCK_ROLE_CNT];$/;"	v	typeref:struct:block	file:
block_first	block.c	/^block_first (void)$/;"	f
block_get_by_name	block.c	/^block_get_by_name (const char *name)$/;"	f
block_get_role	block.c	/^block_get_role (enum block_type role)$/;"	f
block_name	block.c	/^block_name (struct block *block)$/;"	f
block_next	block.c	/^block_next (struct block *block)$/;"	f
block_operations	block.h	/^struct block_operations$/;"	s
block_print_stats	block.c	/^block_print_stats (void)$/;"	f
block_read	block.c	/^block_read (struct block *block, block_sector_t sector, void *buffer)$/;"	f
block_register	block.c	/^block_register (const char *name, enum block_type type,$/;"	f
block_sector_t	block.h	/^typedef uint32_t block_sector_t;$/;"	t
block_set_role	block.c	/^block_set_role (enum block_type role, struct block *block)$/;"	f
block_size	block.c	/^block_size (struct block *block)$/;"	f
block_type	block.c	/^block_type (struct block *block)$/;"	f
block_type	block.h	/^enum block_type$/;"	g
block_type_name	block.c	/^block_type_name (enum block_type type)$/;"	f
block_write	block.c	/^block_write (struct block *block, block_sector_t sector, const void *buffer)$/;"	f
buf	intq.h	/^    uint8_t buf[INTQ_BUFSIZE];  \/* Buffer. *\/$/;"	m	struct:intq
buffer	input.c	/^static struct intq buffer;$/;"	v	typeref:struct:intq	file:
busy_wait	timer.c	/^busy_wait (int64_t loops) $/;"	f	file:
caps_lock	kbd.c	/^static bool caps_lock;$/;"	v	file:
channel	ide.c	/^    struct channel *channel;    \/* Channel that disk is attached to. *\/$/;"	m	struct:ata_disk	typeref:struct:ata_disk::channel	file:
channel	ide.c	/^struct channel$/;"	s	file:
channels	ide.c	/^static struct channel channels[CHANNEL_CNT];$/;"	v	typeref:struct:channel	file:
chars	kbd.c	/^    const char *chars;          \/* chars[0] has scancode first_scancode,$/;"	m	struct:keymap	file:
check_device_type	ide.c	/^check_device_type (struct ata_disk *d) $/;"	f	file:
check_sector	block.c	/^check_sector (struct block *block, block_sector_t sector)$/;"	f	file:
clear_row	vga.c	/^clear_row (size_t y) $/;"	f	file:
cls	vga.c	/^cls (void)$/;"	f	file:
cmos_read	rtc.c	/^cmos_read (uint8_t index)$/;"	f	file:
completion_wait	ide.c	/^    struct semaphore completion_wait;   \/* Up'd by interrupt handler. *\/$/;"	m	struct:channel	typeref:struct:channel::semaphore	file:
cx	vga.c	/^static size_t cx, cy;$/;"	v	file:
cy	vga.c	/^static size_t cx, cy;$/;"	v	file:
descramble_ata_string	ide.c	/^descramble_ata_string (char *string, int size) $/;"	f	file:
dev_no	ide.c	/^    int dev_no;                 \/* Device 0 or 1 for master or slave. *\/$/;"	m	struct:ata_disk	file:
devices	ide.c	/^    struct ata_disk devices[2];     \/* The devices on this channel. *\/$/;"	m	struct:channel	typeref:struct:channel::ata_disk	file:
earlist_wakeup	timer.c	/^bool earlist_wakeup (const struct list_elem *a, const struct list_elem *b, void *aux)$/;"	f
expecting_interrupt	ide.c	/^    bool expecting_interrupt;   \/* True if an interrupt is expected, false if$/;"	m	struct:channel	file:
fb	vga.c	/^static uint8_t (*fb)[COL_CNT][2];$/;"	v	file:
find_cursor	vga.c	/^find_cursor (size_t *x, size_t *y) $/;"	f	file:
first_scancode	kbd.c	/^    uint8_t first_scancode;     \/* First scancode. *\/$/;"	m	struct:keymap	file:
found_partition	partition.c	/^found_partition (struct block *block, uint8_t part_type,$/;"	f	file:
head	intq.h	/^    int head;                   \/* New data is written here. *\/$/;"	m	struct:intq
how	shutdown.c	/^static enum shutdown_type how = SHUTDOWN_NONE;$/;"	v	typeref:enum:shutdown_type	file:
ide_init	ide.c	/^ide_init (void) $/;"	f
ide_operations	ide.c	/^static struct block_operations ide_operations =$/;"	v	typeref:struct:block_operations	file:
ide_operations	ide.c	/^static struct block_operations ide_operations;$/;"	v	typeref:struct:block_operations	file:
ide_read	ide.c	/^ide_read (void *d_, block_sector_t sec_no, void *buffer)$/;"	f	file:
ide_write	ide.c	/^ide_write (void *d_, block_sector_t sec_no, const void *buffer)$/;"	f	file:
identify_ata_device	ide.c	/^identify_ata_device (struct ata_disk *d) $/;"	f	file:
init	vga.c	/^init (void)$/;"	f	file:
init_poll	serial.c	/^init_poll (void) $/;"	f	file:
input_full	input.c	/^input_full (void) $/;"	f
input_getc	input.c	/^input_getc (void) $/;"	f
input_init	input.c	/^input_init (void) $/;"	f
input_putc	input.c	/^input_putc (uint8_t key) $/;"	f
input_sector	ide.c	/^input_sector (struct channel *c, void *sector) $/;"	f	file:
interrupt_handler	ide.c	/^interrupt_handler (struct intr_frame *f) $/;"	f	file:
intq	intq.h	/^struct intq$/;"	s
intq_empty	intq.c	/^intq_empty (const struct intq *q) $/;"	f
intq_full	intq.c	/^intq_full (const struct intq *q) $/;"	f
intq_getc	intq.c	/^intq_getc (struct intq *q) $/;"	f
intq_init	intq.c	/^intq_init (struct intq *q) $/;"	f
intq_putc	intq.c	/^intq_putc (struct intq *q, uint8_t byte) $/;"	f
invariant_keymap	kbd.c	/^static const struct keymap invariant_keymap[] = $/;"	v	typeref:struct:keymap	file:
irq	ide.c	/^    uint8_t irq;                \/* Interrupt in use. *\/$/;"	m	struct:channel	file:
is_ata	ide.c	/^    bool is_ata;                \/* Is device an ATA disk? *\/$/;"	m	struct:ata_disk	file:
issue_pio_command	ide.c	/^issue_pio_command (struct channel *c, uint8_t command) $/;"	f	file:
kbd_init	kbd.c	/^kbd_init (void) $/;"	f
kbd_print_stats	kbd.c	/^kbd_print_stats (void) $/;"	f
key_cnt	kbd.c	/^static int64_t key_cnt;$/;"	v	file:
keyboard_interrupt	kbd.c	/^keyboard_interrupt (struct intr_frame *args UNUSED) $/;"	f	file:
keyboard_interrupt	kbd.c	/^static intr_handler_func keyboard_interrupt;$/;"	v	file:
keymap	kbd.c	/^struct keymap$/;"	s	file:
left_alt	kbd.c	/^static bool left_alt, right_alt;        \/* Left and right Alt keys. *\/$/;"	v	file:
left_ctrl	kbd.c	/^static bool left_ctrl, right_ctrl;      \/* Left and right Ctl keys. *\/$/;"	v	file:
left_shift	kbd.c	/^static bool left_shift, right_shift;    \/* Left and right Shift keys. *\/$/;"	v	file:
list_elem	block.c	/^    struct list_elem list_elem;         \/* Element in all_blocks. *\/$/;"	m	struct:block	typeref:struct:block::list_elem	file:
list_elem_to_block	block.c	/^list_elem_to_block (struct list_elem *list_elem)$/;"	f	file:
lock	ide.c	/^    struct lock lock;           \/* Must acquire to access the controller. *\/$/;"	m	struct:channel	typeref:struct:channel::lock	file:
lock	intq.h	/^    struct lock lock;           \/* Only one thread may wait at once. *\/$/;"	m	struct:intq	typeref:struct:intq::lock
loops_per_tick	timer.c	/^static unsigned loops_per_tick;$/;"	v	file:
map_key	kbd.c	/^map_key (const struct keymap k[], unsigned scancode, uint8_t *c) $/;"	f	file:
mode	serial.c	/^static enum { UNINIT, POLL, QUEUE } mode;$/;"	v	typeref:enum:__anon1	file:
move_cursor	vga.c	/^move_cursor (void) $/;"	f	file:
name	block.c	/^    char name[16];                      \/* Block device name. *\/$/;"	m	struct:block	file:
name	ide.c	/^    char name[8];               \/* Name, e.g. "hda". *\/$/;"	m	struct:ata_disk	file:
name	ide.c	/^    char name[8];               \/* Name, e.g. "ide0". *\/$/;"	m	struct:channel	file:
newline	vga.c	/^newline (void)$/;"	f	file:
next	intq.c	/^next (int pos) $/;"	f	file:
not_empty	intq.h	/^    struct thread *not_empty;   \/* Thread waiting for not-empty condition. *\/$/;"	m	struct:intq	typeref:struct:intq::thread
not_full	intq.h	/^    struct thread *not_full;    \/* Thread waiting for not-full condition. *\/$/;"	m	struct:intq	typeref:struct:intq::thread
ops	block.c	/^    const struct block_operations *ops;  \/* Driver operations. *\/$/;"	m	struct:block	typeref:struct:block::block_operations	file:
output_sector	ide.c	/^output_sector (struct channel *c, const void *sector) $/;"	f	file:
partition	partition.c	/^struct partition$/;"	s	file:
partition_operations	partition.c	/^static struct block_operations partition_operations =$/;"	v	typeref:struct:block_operations	file:
partition_operations	partition.c	/^static struct block_operations partition_operations;$/;"	v	typeref:struct:block_operations	file:
partition_read	partition.c	/^partition_read (void *p_, block_sector_t sector, void *buffer)$/;"	f	file:
partition_scan	partition.c	/^partition_scan (struct block *block)$/;"	f
partition_type_name	partition.c	/^partition_type_name (uint8_t type)$/;"	f	file:
partition_write	partition.c	/^partition_write (void *p_, block_sector_t sector, const void *buffer)$/;"	f	file:
pit_configure_channel	pit.c	/^pit_configure_channel (int channel, int mode, int frequency)$/;"	f
print_stats	shutdown.c	/^print_stats (void)$/;"	f	file:
putc_poll	serial.c	/^putc_poll (uint8_t byte) $/;"	f	file:
read	block.h	/^    void (*read) (void *aux, block_sector_t, void *buffer);$/;"	m	struct:block_operations
read_cnt	block.c	/^    unsigned long long read_cnt;        \/* Number of sectors read. *\/$/;"	m	struct:block	file:
read_partition_table	partition.c	/^read_partition_table (struct block *block, block_sector_t sector,$/;"	f	file:
real_time_delay	timer.c	/^real_time_delay (int64_t num, int32_t denom)$/;"	f	file:
real_time_sleep	timer.c	/^real_time_sleep (int64_t num, int32_t denom) $/;"	f	file:
reg_alt_status	ide.c	31;"	d	file:
reg_base	ide.c	/^    uint16_t reg_base;          \/* Base I\/O port. *\/$/;"	m	struct:channel	file:
reg_command	ide.c	25;"	d	file:
reg_ctl	ide.c	30;"	d	file:
reg_data	ide.c	17;"	d	file:
reg_device	ide.c	23;"	d	file:
reg_error	ide.c	18;"	d	file:
reg_lbah	ide.c	22;"	d	file:
reg_lbal	ide.c	20;"	d	file:
reg_lbam	ide.c	21;"	d	file:
reg_nsect	ide.c	19;"	d	file:
reg_status	ide.c	24;"	d	file:
reset_channel	ide.c	/^reset_channel (struct channel *c) $/;"	f	file:
right_alt	kbd.c	/^static bool left_alt, right_alt;        \/* Left and right Alt keys. *\/$/;"	v	file:
right_ctrl	kbd.c	/^static bool left_ctrl, right_ctrl;      \/* Left and right Ctl keys. *\/$/;"	v	file:
right_shift	kbd.c	/^static bool left_shift, right_shift;    \/* Left and right Shift keys. *\/$/;"	v	file:
rtc_get_time	rtc.c	/^rtc_get_time (void)$/;"	f
select_device	ide.c	/^select_device (const struct ata_disk *d)$/;"	f	file:
select_device_wait	ide.c	/^select_device_wait (const struct ata_disk *d) $/;"	f	file:
select_sector	ide.c	/^select_sector (struct ata_disk *d, block_sector_t sec_no)$/;"	f	file:
serial_flush	serial.c	/^serial_flush (void) $/;"	f
serial_init_queue	serial.c	/^serial_init_queue (void) $/;"	f
serial_interrupt	serial.c	/^serial_interrupt (struct intr_frame *f UNUSED) $/;"	f	file:
serial_interrupt	serial.c	/^static intr_handler_func serial_interrupt;$/;"	v	file:
serial_notify	serial.c	/^serial_notify (void) $/;"	f
serial_putc	serial.c	/^serial_putc (uint8_t byte) $/;"	f
set_serial	serial.c	/^set_serial (int bps)$/;"	f	file:
shifted_keymap	kbd.c	/^static const struct keymap shifted_keymap[] = $/;"	v	typeref:struct:keymap	file:
shutdown	shutdown.c	/^shutdown (void)$/;"	f
shutdown_configure	shutdown.c	/^shutdown_configure (enum shutdown_type type)$/;"	f
shutdown_power_off	shutdown.c	/^shutdown_power_off (void)$/;"	f
shutdown_reboot	shutdown.c	/^shutdown_reboot (void)$/;"	f
shutdown_type	shutdown.h	/^enum shutdown_type$/;"	g
signal	intq.c	/^signal (struct intq *q UNUSED, struct thread **waiter) $/;"	f	file:
size	block.c	/^    block_sector_t size;                 \/* Size in sectors. *\/$/;"	m	struct:block	file:
sleep_list	timer.c	/^static struct list sleep_list;$/;"	v	typeref:struct:list	file:
speaker_beep	speaker.c	/^speaker_beep (void)$/;"	f
speaker_off	speaker.c	/^speaker_off (void)$/;"	f
speaker_on	speaker.c	/^speaker_on (int frequency)$/;"	f
start	partition.c	/^    block_sector_t start;               \/* First sector within device. *\/$/;"	m	struct:partition	file:
tail	intq.h	/^    int tail;                   \/* Old data is read here. *\/$/;"	m	struct:intq
ticks	timer.c	/^static int64_t ticks;$/;"	v	file:
time_t	rtc.h	/^typedef unsigned long time_t;$/;"	t
timer_calibrate	timer.c	/^timer_calibrate (void) $/;"	f
timer_elapsed	timer.c	/^timer_elapsed (int64_t then) $/;"	f
timer_init	timer.c	/^timer_init (void) $/;"	f
timer_interrupt	timer.c	/^static intr_handler_func timer_interrupt;$/;"	v	file:
timer_interrupt	timer.c	/^timer_interrupt (struct intr_frame *args UNUSED)$/;"	f	file:
timer_mdelay	timer.c	/^timer_mdelay (int64_t ms) $/;"	f
timer_msleep	timer.c	/^timer_msleep (int64_t ms) $/;"	f
timer_ndelay	timer.c	/^timer_ndelay (int64_t ns) $/;"	f
timer_nsleep	timer.c	/^timer_nsleep (int64_t ns) $/;"	f
timer_print_stats	timer.c	/^timer_print_stats (void) $/;"	f
timer_sleep	timer.c	/^timer_sleep (int64_t ticks) $/;"	f
timer_ticks	timer.c	/^timer_ticks (void) $/;"	f
timer_udelay	timer.c	/^timer_udelay (int64_t us) $/;"	f
timer_usleep	timer.c	/^timer_usleep (int64_t us) $/;"	f
too_many_loops	timer.c	/^too_many_loops (unsigned loops) $/;"	f	file:
txq	serial.c	/^static struct intq txq;$/;"	v	typeref:struct:intq	file:
type	block.c	/^    enum block_type type;                \/* Type of block device. *\/$/;"	m	struct:block	typeref:enum:block::block_type	file:
unshifted_keymap	kbd.c	/^static const struct keymap unshifted_keymap[] = $/;"	v	typeref:struct:keymap	file:
vga_putc	vga.c	/^vga_putc (int c)$/;"	f
wait	intq.c	/^wait (struct intq *q UNUSED, struct thread **waiter) $/;"	f	file:
wait_until_idle	ide.c	/^wait_until_idle (const struct ata_disk *d) $/;"	f	file:
wait_while_busy	ide.c	/^wait_while_busy (const struct ata_disk *d) $/;"	f	file:
write	block.h	/^    void (*write) (void *aux, block_sector_t, const void *buffer);$/;"	m	struct:block_operations
write_cnt	block.c	/^    unsigned long long write_cnt;       \/* Number of sectors written. *\/$/;"	m	struct:block	file:
write_ier	serial.c	/^write_ier (void) $/;"	f	file:
